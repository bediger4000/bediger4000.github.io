<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN" "file:///home/bediger/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>There is A Perfect Editor</title>
<meta name="google-site-verification" content="ixC4wtdetOlWNosRSwl6CFgRutGwfbq_9r9z534uRkY" />
<meta name="description" content="Bibliography of technical articles and papers relating to text editors" />
<meta name="keywords" content="text editor, perfect editor, bibliography" />
<link rev="MADE" href="mailto:bediger@stratigery.com" />
</head>
<body>
<center>
<h1>Research Shows: There is A Perfect Editor</h1>
<strong>Compiled by Bruce Ediger</strong><br/>
<a href="index.html">Bruce Ediger's home page</a></center>

<script type="text/javascript" language="JavaScript" src="partyon.js">
</script>

<blockquote><strong>"The comparison of widely varying text editors
has only recently evolved beyond subjective preference and
name-calling."</strong><br/>
<center>- Nathaniel S. Borenstein, <a
href="#borenstein85">1985</a></center>
</blockquote>

<p>The "My editor is better than your editor" <a href="#argument">argument</a>
easily comprises the longest-running
continuous argument in computer programming. One can easily dismiss
most of the common arguments on the topic, since the
argument-makers appear ill-informed, no definitions of terms ever
get offered or agreed-upon, hidden assumptions riddle the arguments
and subjective preference carries more weight than experiment.
Nevertheless, editor users bring up important points on
ease-of-use, editing power, and what sort of interface an editor
possesses. Despite endless discussion, poorly-formed concepts like
<a href="#easy">"easy"</a>, <a href="#powerful">"powerful"</a>, <a
href="#consistency">"consistent"</a> <a
href="#intuitive">"intuitive"</a> and their opposites appear in
most of the arguments. No two arguers agree on what the terms
mean.</p>

<p>In order to form more perfect arguments, I present a first cut
at a bibliography of real research that seems directed toward
finding the perfect editor. I did not perform an exhaustive
literature search, so please <a
href="mailto:bediger@stratigery.com">inform</a> me of any missing
citations. I'm missing electronically-retrievable forms for almost
all of these papers.</p>

<hr />
<ul>
<li><a id="borenstein85" name="borenstein85">Borenstein, Nathaniel
S.</a><br/>
<strong><a href="http://portal.acm.org/citation.cfm?id=317456.317475">The Evaluation of Text Editors: A Critical Review of the
Roberts and Moran Methodology Based on New
Experiments.</a></strong><br/>
In <cite>Proceedings CHI '85 Human Factors in Computing Systems</cite><br/>
(San Francisco, April 14-18, 1985) ACM, New York, pp 99-105<br/>
<br/>
<em>Abstract:</em> 

<blockquote>Three text editors were studied using the editor
evaluation methodology developed by Roberts and Moran. The results
are presented as an extension of the studies by Roberts and Moran,
with comparisons to the editors they studied earlier. In addition,
supplementary measurements were taken that suggest minor flaws in
the Roberts and Moran methodology. Further problems with the
methodology are discussed, with an eye toward improving the
methodology in future use. Although three significant problems with
the methodology are reported, the problems are interesting
primarily as lessons of the design of future evaluation
methodologies. The Roberts and Moran methodology remains largely
useful for the purposes for which it was designed.</blockquote>

<p><em>This paper attempts to confirm <a href="#roberts79">Roberts,
1979</a>, and <a href="#roberts83">Roberts &amp; Moran,
1983</a></em></p>
</li>

<li><a id="cook" name="cook">Cook, Ronny, Judy Kay, Greg Ryan,
Richard C Thomas.</a><br/>
<strong>A toolkit for appraising the long term usability of a text
editor.</strong><br/>
Technical Report, <a
href="http://ftp.cs.su.oz.au/pub/tr/index.html">Basser Dept of
Computer Science</a>, University of Sydney<br/>
<br/>
<em>Abstract:</em> 

<blockquote>
<p>We describe a large scale, low cost project that has examined
the way people develop their skill in using fundamental software
tools. The study involved over two thousand users during a
three-year period of use of the <em>sam</em> text editor. The work took
place while the editor was being employed in normal day to day work
- it was not a laboratory experiment.</p>
<p>Our main contributions are first to demonstrate very long-term,
low-cost monitoring with collections of simple analysis tools.
Second, we have started to develop an understanding of how
usability changes in the long term. Third, studies of usability
often concentrate on assessment before a system is released for
widespread use, whereas ours can help inform the long term design
of new tools - a different dimension of usability. In addition we
have mixed snap-shot studies with descriptions of long-term,
gradual change. We can track the full development of the user, even
though the quality of the data is lower than that normally
associated with usability studies.</p>
</blockquote>

<p><em>Documentation on the <a
href="http://www.cs.bell-labs.com/sys/doc/sam/sam.pdf">sam</a> editor
used in the above study.</em></p>

<p><em>See also: <a href="#good1985">Good 85</a>, <a
href="#whiteside82">Whiteside, Wixon &amp; Good, 1982</a>
<a href="#thomas98">Thomas, 1998</a></em></p>
</li>

<li><a id="thomas98" name="thomas98">Thomas, Richard C.</a><br/>
<a href="http://www.amazon.com/exec/obidos/ISBN=3540762094">Long
Term Human-Computer Interaction</a><br/>
Springer-Verlag, 1998, ISBN 3540762094<br/>
<p>This book apparently grew out of <a href="#cook">Cook, Kay, Ryan
&amp; Thomas</a>. One of the authors of that report wrote this
book. The Amazon.com review sounds very interesting.</p>
</li>

<li><a id="good1985" name="good1985">Good, Michael.</a><br/>
<strong><a href="http://home.earthlink.net/~goodclose/chi85.html">The Use of Logging Data in the Design of a New Text Editor.</a></strong><br/>
In <cite>Proceedings CHI '85 Human Factors in Computing Systems</cite><br/>
(San Francisco, April 14-18, 1985) ACM, New York, pp 93-97<br/>
<br/>
<em>Abstract:</em> 

<blockquote>Many different human factors techniques are available
to the designer of a new computer system. This case study examines
how one technique, the use of logging data, was used throughout the
design of a new text editor which is measurably easy to learn and
easy to use. Logging data was used in four areas: keyboard design,
the initial design of the editor's command set, refinements made
later in the design cycle, and the construction of a system
performance benchmark.</blockquote>

<p><em>They ended up with the <a
href="http://www.openvms.compaq.com:8000/73final/6021/6021PRO.HTML">
EVE editor</a>, running under the VMS operating system.
<a href="http://www.decus.org/libcatalog/description_html/v00560.html">
All about</a> EVE.</em></p>
<p><em>Despite the efforts outlined in the above paper, several EVE
users found it lacking. Users can rewrite at least some portions of
EVE, because its programmers wrote EVE in an extension language,
much like Emacs. Arthur E. Ragosta created <a
href="http://www.decus.org/libcatalog/document_html/v00305_1.html">ADAM</a>
to "correct weaknesses in EVE." The Saskatchewan Cancer Foundation
modified EVE to produce <a
href="http://www.decus.org/libcatalog/document_html/v00279_1.html">WEVE</a>.
WEVE "is an EVE editor interface that has been enhanced".</em></p>
<p><em>See also: <a href="#cook">Cook, Kay, Ryan &amp; Thomas</a>,
<a href="#whiteside82">Whiteside, Wixon &amp; Good, 1982</a></em></p>
</li>

<li>Good, M.<br/>
<strong><a href="http://home.earthlink.net/~goodclose/hfs85.html">The iterative design of a new text editor</a></strong><br/>
<cite>In Proc. Human Factors Society 29th Annual Meeting</cite><br/>
(Baltimore, September 29-October 3, 1985), Santa Monica, CA, Vol.
1, pp. 571-574.<br/><br/>
<em>Abstract:</em> 

<blockquote>Iterative design has been strongly recommended as part
of a basic design philosophy for building measurably easy-to-use
computer software. Iterative design was a major technique for
meeting the specified usability goals for Eve, a new text editor
for the VAX/VMS operating system. There was no adverse effect on
the project schedule. Users' problems followed similar patterns to
those encountered in earlier laboratory experiments on operating
systems.</blockquote>
<br/>
</li>
<li><a id="intuitive" name="intuitive">Raskin, J.</a><br/>
<a href="http://www.asktog.com/papers/raskinintuit.html"><strong>Intuitive Equals Familiar</strong></a><br/>
<cite>Communications of the ACM</cite>, vol 37, no 9, September, 1994, pg 17<br/>
<br/>
<em>Excerpt:</em> 

<blockquote>The impression that the phrase "this interface feature
is intuitive" leaves is that the interface works the way the user
does, that normal human "intuition" suffices to use it, that
neither training nor rational thought is necessary, and that it
will feel "natural." We are said to "intuit" a concept when we seem
to suddenly understand it without any apparent effort or previous
exposure to the idea. In common parlance, intuition has the
additional flavor of a nearly supernatural ability humans possess
in varying degrees. Given these connotations, it is as
uncomfortable a term in formal HCI studies as it is a common one in
non-technical publications and in informal conversation about
interfaces.</blockquote>

<p><em>Strictly speaking, the above reference doesn't fit in the
category of "research" about text editors. It more-or-less
constitutes an opinion piece on the definition of
"intuitive".</em></p>
</li>

<li>Landauer, T.K., K.M. Galotti, S Hartwell.<br/>
<strong>Natural Command Names and Initial Learning: A Study of
Text-Editing Terms.</strong><br/>
<cite>Communications of the ACM</cite>, vol 26, no 7, July, 1983<br/>
<br/>
<em>Abstract:</em> 

<blockquote>In the first of two studies of "naturalness" in command
names, computer-naive typists composed instructions to "someone
else" for correcting a sample text. There was great variety in
their task-descriptive lexicon and a lack of correspondence between
both their vocabulary and their underlying conceptions of the
editing operations and those of some computerized text editors. In
the second study, computer-naive typists spent two hours learning
minimal text editing systems that varied in several ways. Lexical
naturalness (frequency of use in Study 1) made little difference in
their performance. By contrast, having different, rather than the
same names for operations requiring different syntax greatly
reduced difficulty. It is concluded that the design of
user-compatible commands involves deeper issues than are captured
by the slogan "naturalness." However, there are limitations to our
observations. Only initial learning of a small set of commands was
at issue and generalizations to other situations will require
further testing.</blockquote>
</li>

<li>Lee, Adrienne Y., Peter W. Foltz, Peter G. Polson.<br/>
<strong>Consistency versus Mnemonics in Text Editor Command
Sets.</strong><br/>
Abstract only, <cite>SIGCHI Bulletin</cite>, vol 23, no 4, October 1991, ISSN 0736-6906<br/>
<br/>
<em>Abstract:</em> 

<blockquote>
<p>This experiment studies the acquisition and retention of text
editor command sets. Previous research has focused on consistent,
mnemonic sets versus inconsistent, non-mnemonic sets (Lee &amp;
Polson, 1988; Walker &amp; Olson, 1988). Although results from
these studies indicate that consistent, mnemonic sets are better
than inconsistent, non-mnemonic sets, it is unclear whether
consistency or mnemonics was the basis for better subject
performance. This study sought to separate this confound. In order
to do this, an condition in addition to those used in the Walker
and Olson study was used in which the commands were consistent but
non-mnemonic.</p>

<p>The results indicated that the consistent, non-mnemonic
condition was learned and recalled better than the inconsistent,
non-mnemonic condition, but worse than consistent, mnemonic
condition. In addition, retroactive and proactive inhibition were
found for those subjects learning both consistent, non-mnemonic,
and inconsistent, non-mnemonic sets. Thus, consistency in text
editor commands may not be enough; mnemonics may also be
needed.</p>
</blockquote>
</li>

<li>Jonathan Grudin, Phil Barnard<br/>
<strong>When does an Abbreviation Become a Word? and related
questions</strong><br/>
In <cite>Proceedings CHI '85 Human Factors in Computing Systems</cite><br/>
(San Francisco, April 14-18, 1985) ACM, New York, pp 121-125<br/>
<br/>
<em>Abstract:</em> 

<blockquote>An experiment is reported in which subjects previously
naive to text editing learned to use a set of editing commands.
Some subjects used abbreviations from the beginning. Others began
by using full command names, then switched to the (optional) use of
abbreviations, either of their own devising or of our selection. We
found significant differences in the number and nature of the
errors produced by subjects in the different conditions. People who
created their own abbreviations did most poorly, and did not appear
to learn from this experience. Those who used abbreviations from
the start were more likely to fall into error through misrecalling
the referent names. The results suggest aspects of the underlying
cognitive representations, with implications for the design of
software interfaces.</blockquote>

<p><em>Bibliography of this paper appears very relevant to
discussions of command-line interfaces (shells).</em></p>
</li>

<li><a id="powerful" name="powerful">Masui, Toshiyuki, Ken
Nakayama.</a><br/>
<strong><a href="http://citeseer.ist.psu.edu/606021.html">Repeat and Predict - Two Keys to Efficient Text
Editing.</a></strong><br/>
In <cite>Proceedings CHI '94 Human Factors in Computing Systems</cite><br/>
(Boston, April 24-28, 1994) ACM, New York, pp 118-123<br/>
<br/>
<em>Abstract:</em> 

<blockquote>We propose a simple and powerful predictive interface
technique for text editing tasks. With our technique called the
<em>dynamic macro</em> creation, when a user types a special
"repeat" key after doing repetitive operations in a text editor, an
editing sequence corresponding to one iteration is detected,
defined as a macro, and executed at the same time. Although being
simple, a wide range of repetitive tasks can be performed just by
typing the repeat key. When we use another special "predict" key
for conventional prediction techniques in addition to the repeat
key, wider range of prediction schemes can be performed depending
on the order of using these two keys.</blockquote>
</li>

<li><a id="stanley96" name="stanley96">Stanley R. Page, Todd J.
Johnsgard, Uhl Albert, C. Dennis Allen</a><br/>
<strong><a
href="http://www.acm.org/sigchi/chi96/proceedings/papers/Page/srp_txt.htm">
User Customization of a Word Processor</a></strong><br/>
In <cite><a href="http://www.acm.org/sigchi/chi96/proceedings/index.htm">Proceedings CHI '96</a></cite><br/>
(Vancouver, British Columbia, April 13-18, 1996) ACM, New York<br/>
<br/>
<em>Abstract:</em> 

<blockquote>The purpose of the study was to identify the
customization changes users typically make to their word processor.
Ninety-two percent of the participants customized their software in
some way. Participants who used the software most heavily also did
the most customization (p &lt; .05). Most of the customization was
done to facilitate the participants' work practices. The most
common changes involved providing easier access to custom or
often-used functionality. Button Bars seemed to provide an easy and
effective means for participants to customize access to the
functionality they wanted. Few participants customized the visual
appearance of the interface.</blockquote>

<p><em>They studied the WordPerfect 6.0a word processor for
Windows.</em></p>

<p><em>Most of the Open Source editors (<a
href="http://www.vim.org">Vim</a>, <a
href="http://www.clark.net/pub/dickey/vile/vile.html">vile</a>,
EMACS, <a href="http://www.xemacs.org/">Xemacs</a>) allow, and even
encourage, extensive customization of the editor's appearance.
People cite ease of customization as an advantageous feature of the
editors that support it. Why did the authors of this study find so
few participants doing that kind of customization?</em></p>
</li>

<li>Mo, D.H., and Witten, I.H.<br/>
<strong>Learning text editing tasks from examples: a procedural
approach.</strong><br/>
<cite>IEEE Computer</cite>, vol 23, no. 11, November 1990, pp 41-49<br/>
<p>Apparently also appears in:</p>

<strong>Watch What I Do: Programming by Demonstration</strong><br/>
edited by Cypher, Halbert, Kurlander, Lieberman, Maulsby, Myers and Turransky<br/>
1993, MIT Press, Cambridge, MA, ISBN 0-262-03213-9<br/>
<br/>
</li>

<li>Neal, Lisa Rubin.<br/>
<strong>Cognition-Sensitive Design and User Modeling for
Syntax-Directed Editors.</strong><br/>
In <cite>Proceedings CHI+GI 1987</cite><br/>
(Toronto, April 5-9, 1987) ACM, New York, pp 27-32<br/>
<br/>
 <em>Abstract:</em> 

<blockquote>
<p>Syntax-directed editors were created with the intent of aiding
in and improving the programming process. Despite their potential,
they have not been successful, as evidenced by limited use. In
general, they are perceived as being too difficult to use and the
benefits of their use are outweighed by the difficulties.</p>

<p>We believe that the cognitive styles and skills of the users
have been ignored in the design process. In this paper we present
some of our initial results which show that cognitive styles vary
over a significant spectrum and that their consideration in the
design of a syntax-directed editor will result in an intelligent
tool that will be right for the cognitive skills and expertise of
an individual user. In turn, and approach to design that takes
cognitive variation into account would support the construction of
syntax-directed editors which are successfully used.</p>
</blockquote>
</li>

<li>Nix, R.P.<br/>
<strong>Editing by Example.</strong><br/>
<cite>ACM Transactions on Programming Languages and Systems</cite>,
vol 7, no. 4, October 1985, pp 600-621<br/>
<br/>
</li>

<li>Poller, M.F., Garter, S.K.<br/>
<strong>A Comparative Study of Moded and Modeless Text Editing by
Experienced Editor Users.</strong><br/>
In <cite>Proceedings of CHI '83</cite> pp 166-170<br/>
<br/>
 <em>Excerpt:</em> 

<blockquote>The issue we are concerned with in this paper is not
that of modes in general, but rather the more specific question of
how editors should handle text insertions. In this context, moded
editing means that the editor user must enter a special command
before text is inserted and another special command to end the text
insertion and return to the command mode. Ordinary printing
characters typed while in insertion mode are entered as text. The
same characters entered while the editor is in the command mode are
treated as commands. Modeless editing is different; ordinary
characters are entered directly as text. There are no special
command required to enter or stop entering text.</blockquote>

<br/>
 <em>Summary and Conclusions:</em> 

<blockquote>Experienced <em>emacs</em> and <em>vi</em> users, who
use their editors to write and edit English text, performed a
series of basic editing tasks and wrote a movie or book review. Our
findings suggest that moded editing, as exemplified by the
<em>vi</em> editor, may be preferable for fixed editing tasks,
while modeless editing, as exemplified by the <em>emacs</em>
editor, may have some advantages for free composing.</blockquote>

<blockquote>The <em>vi</em> subjects left fewer uncorrected errors
in their final files than did the <em>emacs</em> subjects when
doing fixed editing tasks from marked up hard copy. The
<em>emacs</em> group tended to take longer to complete the editing
tasks, but the time differences may have resulted from differences
in typing speed.</blockquote>

<blockquote>Moded errors do not seem to be a problem for
experienced <em>vi</em> users. The <em>vi</em> group made few moded
errors, and those few were rapidly corrected. Futhermore, modeless
editing may not totally avoid moded type errors, since the
<em>emacs</em> group made errors that were similar in nature to the
<em>vi</em> moded errors.</blockquote>

<blockquote>Modeless editing may allow people to edit more freely
while they are composing. The <em>emacs</em> subjects tended to do
more of their editing in the first draft stage of composing than
did the <em>vi</em> group. However the two groups were similar in
total editing, composing time, and most writing style
variables.</blockquote>

<blockquote>The ideal editor design would combine moded and
modeless editing features. To do this, we suggest adding some basic
cursor moving and delete commands using control character names to
the inserting text modes. This design provides the editing
advantages of moded editing, and, at the same time, allows people
who like to edit while composing to do so without having to exit
and reenter insertion modes.</blockquote>

<blockquote>This study was not an evaluation of <em>emacs</em> or
<em>vi</em> as total editors. Both are sophisticated editors that
provide many features not explored in this study. Although we
interpret our results as showing that <em>vi</em> was preferable
for the fixed editing tasks investigated, we can easily think of
cases in which <em>emacs</em> would be a far more desirable
editor.</blockquote>

<p><em>People usually consider emacs and vi only as "programmer's
editors". Based on the editing tasks examined, the authors of this
paper wanted to investigate "moded vs modeless" for a wider
context.</em></p>

<p>Thanks to Eric Fischer of the University of Chicago for finding,
copying and mailing me this paper. I remain deeply in debt to
him.</p>
</li>

<li>Polson, Peter G., David E. Kieras.<br/>
<strong>A Quantitative Model of the Learning and Performance of
Text Editing Knowledge.</strong><br/>
In <cite>Proceedings CHI '85 Human Factors in Computing Systems</cite><br/>
(San Francisco, April 14-18, 1985) ACM, New York, pp 207-212<br/>
<br/>
 <em>Abstract:</em> 

<blockquote>A model of manuscript editing, implemented as a
simulation program, is described in this paper. The model provides
an excellent, quantitative description of learning, transfer and
performance data from two experiments on text editing methods.
Duplications of the underlying theory for the design process are
briefly discussed.</blockquote>
</li>

<li>Douglas, S. and Moran, T.<br/>
<strong>Learning text editor semantics by example.</strong><br/>
In <cite>Proceedings CHI '83 Human Factors in Computing Systems</cite><br/>
(Boston, December 12-15, 1983) ACM, New York<br/>
<br/>
</li>

<li>Lewis, C. and Mack, R.<br/>
<strong>Learning to use a text editor: Evidence from "Thinking
Aloud" Protocols</strong><br/>
In <cite>Proceedings of Human Factors in Computing Systems Conference</cite><br/>
(Gaithersburg, Maryland, 1982) National Bureau of Standards<br/>
<br/>
</li>

<li>Mack, R., Lewis, C. and Carroll, J.<br/>
<strong>Learning to use word processors: Problems and
prospects</strong><br/>
<cite>ACM Transactions in Office Information Systems</cite>, 1(3), 1983, 254-271.<br/>
<br/>
</li>

<li>Mack, R.L.<br/>
<strong>Understanding text editing: Evidence from predictions and descriptions given by computer-naive people</strong><br/>
<cite>Res. Rep. RC 10333</cite>, IBM Watson Research Center, Yorktown Heights, N.Y., Jan. 18, 1984
<br/>
<p><em>In 1984 it might have seemed appropriate to use &quot;computer-naive&quot; people
to understand text editing.  In 2002 that same usage might seem naive.</em></p>
<br/>
</li>

<li>J M Carroll<br/>
<strong>The Nurnberg Funnel: designing minimalist instruction for
practical computer skill</strong><br/>
MIT Press, 1990, Cambridge, MA.<br/>
<br/>
</li>

<li>Mack, R.<br/>
<strong>Understanding text editing: Evidence from predictions and
descriptions given by computer-naive people.</strong><br/>
IBM Research Report RC 10333, IBM Thomas J. Watson Research Center,
Yorktown Heights, NY, 1984<br/>
<br/>
</li>

<li>Polson, Peter G., Susan Bovair, David Kieras.<br/>
<strong>Transfer Between Text Editors.</strong><br/>
In <cite>Proceedings CHI+GI 1987</cite><br/>
(Toronto, April 5-9, 1987) ACM, New York, pp 27-32<br/>
<br/>
 <em>Abstract:</em> 

<blockquote>This paper describes a successful test of a
quantitative model that accounts for large positive transfer
effects between similar screen editors, between different line
editors and from line editors to a screen editor, and between text
and graphic editors. The model is tested in an experiment using two
very similar full-screen text-editors differing only in the
structure of their editing commands, verb-noun vs. noun-verb.
Quantitative predictions for training time were derived from a
production system model based on the Polson and Kieras model of
text editing.</blockquote>
</li>

<li>Mark K. Singley and John R. Anderson<br/>
<strong>The transfer of text-editing skill</strong><br/>
<cite>Internat. J. Man-Machine Studies</cite> 22 (1985),
403-423.<br/>
<br/>
</li>

<li>Peter G. Polson, David E. Kieras<br/>
<strong>A Quantitative Model of the Learning and Performance of
Text-Editing Knowledge</strong><br/>
in <cite>Human-Computer Interaction</cite>, edited by Jenny Preece and Laurie Keller<br/>
Prentice Hall, 1990, ISBN 0-13-444910-X.<br/>
<br/>
</li>

<li>Martin Heydemann, Rudolf Hoffmann, Rainer Schmidt<br/>
<strong>Interference among Text-Editing Commands: Fan-Effects and
the Role of System Consistency</strong><br/>
in <cite>Cognitive Ergonomics: Contributions from Experimental Psychology</cite><br/>
North-Holland, Elsevier Science Publishers, 1992, ISBN
0-444-89504-3<br/>
<br/>
</li>

<li>Yvonne Waern<br/>
<strong>On the Microstructure of Learning a Wordprocessor</strong><br/>
in <cite>Cognitive Ergonomics: Contributions from Experimental Psychology</cite><br/>
North-Holland, Elsevier Science Publishers, 1992, ISBN
0-444-89504-3<br/>
<br/>
</li>

<li><a id="roberts79" name="roberts79">Roberts, T.L.</a><br/>
<strong>Evaluation of computer text editors.</strong><br/>
Report SSL-79-9, Xerox PARC, Palo Alto, CA, November, 1979<br/>
<br/>
</li>

<li><a id="roberts83" name="roberts83">Roberts, T.L. and Moran, T.P.</a><br/>
<strong><a href="http://portal.acm.org/citation.cfm?id=2163.2164">The evaluation of text editors: methodology and empirical results.</a></strong><br/>
<cite>Communications of the ACM</cite>, vol 26, April 1983, pp 265-283<br/>
<br/>
</li>

<li>Roberts, Teresa L.<br/>
<strong>Evaluation of Computer Text Editors.</strong><br/>
PhD thesis, Stanford University, 1979<br/>
<br/>
</li>

<li>Rosson, M.B.<br/>
<strong>Patterns of Experience in Text Editing.</strong><br/>
In <cite>Proceedings of CHI '83</cite> pp 171-175<br/>
Also appears in <cite>Human Factors</cite> (1984) 26,
463-475.<br/>
<br/>
<em>Commentary from <a href="#stanley96">Page, Johnsgard, Albert
&amp; Allen</a>:</em> 

<blockquote>Rosson did extensive research on users of a
text-editor. She found that programmers made extensive use of
customization features (reassigning keys and writing macros) but
secretaries did not. She also found that the amount of experience
with the editor and text-editors in general was a good predictor of
the amount of customization done.</blockquote>
</li>

<li><a id="whiteside82" name="whiteside82">Whiteside, J., Archer,
N., Wixon, D., Good, M.</a><br/>
<strong><a href="http://home.earthlink.net/~goodclose/oa82.html">How people really use text editors.</a></strong><br/>
Digital Equipment Technical Report, Human Engineering Research,
Nashua, New Hampshire, 1982<br/>
<p>Also said to appear in <cite>SIGOA Newsletter</cite> 3, 1 (June 1982), pp 29-40.</p>

<em>Abstract:</em> 

<blockquote>Keystroke statistics were collected on editing systems
while people performed their normal work. Knowledge workers used an
experimental editor, and secretaries used a word processor. Results
show a consistent picture of free use patterns in both settings. Of
the total number of keystrokes, text entry accounted for
approximately 1/2, cursor movement for about 1/4, deletion for
about 1/8, and all other functions for the remaining 1/8. Analysis
of keystroke transitions and editing states is also presented.
Implications for past research, editor design, keyboard layout, and
benchmark tests are discussed.</blockquote>

<em>Commentary from <a href="#good1985">Good, 1985</a>:</em> 

<blockquote>EPT (Editor Prototyping Tool) is a small editor with 29
commands, designed specifically for research purposes. The logging
sample of over 500,000 keystrokes was collected from six members of
a human factors research group over a two-month period, measuring
212 person-hours of use.</blockquote>

<p><em>See also: <a href="#good1985">Good 85</a>, <a
href="#cook">Cook, Kay, Ryan &amp; Thomas</a>,</em></p>

<br/>
</li>

<li><a id="easy" name="easy">Whiteside, John, Sandra Jones, Paula
S. Levy, Dennis Wixon.</a><br/>
<strong>User Performance with Command, Menu, and Iconic Interfaces</strong><br/>
In <cite>Proceedings CHI '85 Human Factors in Computing Systems</cite><br/>
(San Francisco, April 14-18, 1985) ACM, New York, pp 185-191<br/>
<br/>
<em>Abstract:</em> 

<blockquote>
<p>Performance and subjective reactions of 76 users of varying
levels of computer experience were measured with 7 different
interfaces representing command, menu and iconic interface styles.
The results suggest three general conclusions:</p>

<ul>
<li>there are large usability differences between contemporary
systems,</li>

<li>there is no necessary tradeoff between ease of use and ease of
learning</li>

<li>interface style is not related to performance or preference
(but careful design is).</li>
</ul>

<p>Difficulties involving system feedback, input forms, help
systems and navigation aids occurred in all styles of interface,
command, menu and iconic. New interface technology did not solve
old human factors problems.</p>
</blockquote>
</li>

<li>Young, Richard M. and Joyce Whittington.<br/>
<strong>Using a Knowledge Analysis to Predict Conceptual Errors in
Text-Editor Usage.</strong><br/>
In <cite>Proceedings of CHI, 1990</cite><br/>
(Seattle, Washington, April 1-5, 1990) ACM, New York, 1990, pp 91-97<br/>
<br/>
</li>

<li>Gould, John D, Clayton Lewis, Vincent Barnes.<br/>
<strong>Effects of Cursor Speed on Text-Editing.</strong><br/>
In <cite>Proceedings CHI '85 Human Factors in Computing Systems</cite><br/>
(San Francisco, April 14-18, 1985) ACM, New York, pp 7-10<br/>
<br/>
<em>Abstract:</em> 

<blockquote>Nine participants used a full screen computer
text-editor (XEDIT) with an IBM 3277 terminal to edit marked-up
documents at each of three cursor speeds (3.3, 4.7 and 11.0
cm/sec.). Results show that 9% of editing time was spent
controlling and moving the cursor, regardless of cursor speed. The
variations in cursor speed studied did not seem to act as a pacing
device for the entire editing task.</blockquote>
</li>

<li>Green, T.R.G and Payne, S.J.<br/>
<strong>Organization and learnability in computer
languages.</strong><br/>
<cite>Int. J. Man-Machine Studies</cite> 21, (1984), 7-18.<br/>
<br/>
<em>Summary:</em> 

<blockquote>Green and Payne regularized EMACS commands along a
single set of organizing principles and produced dramatically
better performance in a learning task.</blockquote>
</li>

<li><a id="consistency" name="consistency">Nielsen, J.</a><br/>
<strong>Coordinating user interfaces for
consistency.</strong><br/>
<cite>SIGCHI Bulletin</cite> 20, (1989), 63-65.<br/>
<br/>
<em>Commentary:</em> 

<blockquote>In 1988, a two-day workshop of 15 experts was unable to
produce a definition of consistency.</blockquote>

<p>Jakob Nielsen edited a book with this same title. I don't know
what relationship the book and the SIGCHI bulletin possess.<br/>
<strong><a
href="http://www.useit.com/jakob/constbook.html">Coordinating User
Interfaces for Consistency</a></strong><br/>
Academic Press, Boston, MA, 1989. ISBN 0-12-518400-X
(hardcover)</p>
</li>

<li>Grudin, Jonathan<br/>
<strong>The Case Against User Interface Consistency</strong><br/>
<cite>Communications of the ACM</cite>, vol 32, no 10, October, 1989<br/>
<br/>
<em>Excerpt:</em> 

<blockquote>However, ease of learning can conflict with subsequent
ease of use When this happens, priorities must be established
carefully. If learning isn't possible, use will not happen.
However, people buy systems and applications not to learn them, but
to use them. [...] If a consistent interface supports learning but
impedes skilled performance, then consistency is working against
good design.</blockquote>

<em>Excerpt:</em> 

<blockquote>No rule, consistently applied, produces good menu
defaults. Enforcing a blanket consistency will damage the
interface.</blockquote>
</li>

<li>Good, M<br/>
<strong><a href="http://home.earthlink.net/~goodclose/hfs88.html"> User interface consistency in the DECwindows program</a></strong><br/>
In <cite>Proc. Human Factors Society 32nd Annual Meeting</cite>,<br/>
(Anaheim, October 24-28, 1988), Santa Monica, CA, Vol. 1, pp. 259-263.<br/>
<em>Abstract:</em> 
<blockquote>
A major goal of the DECwindows program is to provide a consistent,
state-of-the-art user interface for workstation software.  This
interface extends across operating systems and many different types of
application programs. Within the DECwindows program we have addressed
both the technical and organizational aspects of developing consistent
user interfaces across applications. Traditional methods for developing
user interface consistency, such as the use of an interface style
guide and toolkit, were supplemented with more innovative techniques. An
exhibition and catalog of DECwindows application designs helped to develop
a DECwindows school of interface design. Electronic conferencing software
played an important role in facilitating communication among DECwindows
contributors throughout the company. Preliminary user interviews suggest
that the DECwindows interface style gives a consistent, usable feel to
Digital's workstation applications.
</blockquote>
<em>Documents how Digital Equipment Corporation (R.I.P.) developed
a user interface guide and user interface style. As I recall DECWindows
constituted an X11 window manager and widget style, but I only
used DECWindows briefly many years ago.</em> 
<em>
An early version of this paper appeared in Jakob Nielsen's 1988
<a href="#consistency">Coordinating user interfaces for consistency</a> 
conference.
</em>
<br/>
<br/>
</li>

<li>Manuel, T.<br/>
<strong>Molding computer terminals to human needs.</strong><br/>
<cite>Electronics</cite> (June 30, 1982), 97-109.<br/>
<br/>
Inverted "T" configuration of arrow keys is the most usable.<br/>
<br/>
</li>

<li>JENNIFER 8. LEE<br/>
<strong><a href="http://www.nytimes.com/library/tech/99/08/circuits/articles/12keys.html">Defunct Keys and Odd Commands Still Bedevil Today's PC User</a></strong> 
<p>New York Times article describing PC keyboard layout and its
history.</p>
<br/>
</li>

<li>Nakaseko, M., Grandjean, E., Hunting W. and Gierer, R.<br/>
<strong>Studies on ergonomically designed alphanumeric
keyboards.</strong><br/>
<cite>Human Factors</cite> 27, (1985), 175-187.<br/>
<br/>
</li>

<li>Conrad, R., and Hull, A.<br/>
<strong>The preferred layout for numeral data entry keysets.</strong><br/>
<cite>Ergonomics</cite> 11, (1968), 165-174.<br/>
<br/>
</li>

<li>Norman, D.A., and Fisher, D.<br/>
<strong>Why alphabetic keyboards are not easy to use: Keyboard layout doesn't matter much.</strong><br/>
<cite>Human Factors</cite> 24, (1985), 509-515.<br/>
<br/>
</li>

<li>Noyes, J.<br/>
<strong>The QWERTY Keyboard: A review.</strong><br/>
<cite>Int. J. Man-Machine Studies</cite> 18, 265-281<br/>
<br/>
</li>

<li>S.J. Liebowitz and Stephen E. Margolis<br/>
<strong><a href="http://wwwpub.utdallas.edu/~liebowit/keys1.html">The Fable of the Keys</a></strong><br/>
<cite>Journal of Law and Economics</cite>, vol XXXIII, April 1990, 1-23<br/>
<br/>
<em>Excerpt from Introduction</em> 

<blockquote>In the economic literature on standards, the popular
real-world example of this type of market failure is the standard
Qwerty typewriter keyboard and its competition with the Dvorak
keyboard. This example is noted frequently in newspaper and
magazine reports, seems to be generally accepted as true
[...].<br/>
We show that David's version of the history of the market's
rejection of Dvorak does not report the true history, and we
present evidence that the continued use of Qwerty is efficient
given the current understanding of keyboard design. We conclude
that the example of the Dvorak keyboard is what beehives and
lighthouses were for earlier market-failure fables. It is an
example of market-failure that will not withstand rigorous
examination of the historical record.</blockquote>

<p><em>Liebowitz and Margolis attempt to discredit reports of
efficiency of Dvorak keyboard so they can justify a doctrinaire
free market interpretation of why we still use the QWERTY
keyboard.
In a <a href="http://www.reason.com/news/show/29944.html">1996 Reason magazine article</a>,
they really tip their hand about the motivation for this paper.
</em></p>
</li>

<li>Card, Stuart, William English, and Betty Burr<br/>
<strong>Evaluation of Mouse, Rate Controlled Isometric Joystick, and Text Keys for Text Selection on a CRT</strong><br/>
<cite>Ergonomics</cite>, vol 21, no. o, 1978, pp 601-613.<br/>
<p><em>Said to be why Xerox chose the mouse as pointing device for
the seminal "Alto" computer, the first GUI-based computer.</em></p>
</li>

<li>Erik Altmann, Jill H. Larkin, and Bonnie E. John<br/>
<a href="http://www.acm.org/sigchi/chi95/Electronic/documnts/papers/ea_bdy.htm">Display Navigation By An Expert Programmer: A Preliminary Model Of Memory</a><br/>
In <cite>CHI '95 - Conference on Human Factors in Computing Systems</cite><br/>
Denver, Colorado, May 7 - 11, 1995.<br/>
<p><em>Abstract:</em></p>

<blockquote>Skilled programmers, working on natural tasks, navigate
large information displays with apparent ease. We present a
computational cognitive model suggesting how this navigation may be
achieved. We trace the model on two related episodes of behavior.
In the first, the user acquires information from the display. In
the second, she recalls something about the first display and
scrolls back to it. The episodes are separated by time and by
intervening displays, suggesting that her navigation is mediated by
long-term memory, as well as working memory and the display. In the
first episode, the model automatically learns to recognize what it
sees on the display. In the second episode, a chain of
recollections, cued initially by the new display, leads the model
to imagine what it might have seen earlier. The knowledge from the
first episode recognizes this image, leading the model to scroll in
search of the real thing. This model is a step in developing a
psychology of skilled programmers working on their own
tasks.</blockquote>

<p><em>This excerpt explains why I include this paper:</em></p>

<blockquote>String searching was used only three times. One
instance succeeded, with roughly 2 pages between start position and
target. The two other instances failed, with the string not found.
Both times the user then tried scrolling; both scrolling sequences
also failed, one after 3 pages and the other after 6 pages. While
the very limited use of methods may seem surprising, it is
consistent with a finding that experienced users use small subsets
of the commands available to them in an editor, ignoring even
important cursor-movement commands.</blockquote>

<p><em>This paper constitutes an archetypical example of
researchers not really testing &quot;expert&quot; or &quot;experienced&quot; users. The
designated expert made only limited use of string searching, and
actually fell back on scrolling around in the text, apparently
aimlessly. I believe that very few <strong>real</strong> experts
get studied. Most of the papers on this page examine raw,
completely uneducated users. The conclusions most of the authors
draw seem inapplicable to real experts and sophisticated
users.</em></p>
</li>

<li>Payne, S.J.<br/>
<strong>Display-based action at the user interface</strong><br/>
<cite>Internat. J. Man-Machine Studies</cite> 35 (1991), 275-289. 

<p><em>Said to confirm that even expert users use only small
subsets of editor commands. Might be worth comparing with findings
of <a href="#cook">Cook, Kay, Ryan &amp; Thomas</a>.</em></p>
</li>

<li>Fitts, P.M.<br/>
<strong>The Information Capacity of the Human Motor System in Controlling Amplitude of Movement</strong><br/>
<cite>Journal of Experimental Psychology</cite>, vol 4, 1954, pp 381-391<br/>
<p><em>This paper proposes the famed &quot;Fitt's Law&quot; often used to
justify a particular menu-bar layout</em></p>
</li>

<li>Neff Walker, John B. Smelcer<br/>
<strong>A Comparison of Selection Times from Walking and Pull-Down
Menus</strong><br/>
In <cite>Proceedings of CHI, 1990</cite><br/>
(Seattle, Washington, April 1-5, 1990) ACM, New York, 1990, pp
221-225<br/>
<p><em>Abstract:</em></p>

<blockquote>This paper reports on an experiment that investigated
factors which effect selection time from walking menus and bar or
pull-down menus. The primary focus was on the use of impenetrable
borders and on expanding target areas on the two menus [sic] types.
The results show that both factors can be used to facilitate menu
selection, with the use of borders being most beneficial. In
addition, the time required to access items from a bar menu is less
than that required for the best walking menu.</blockquote>

<p><em>Lab work justifying a particular menu-bar layout</em></p>
</li>

<li>Johnny Accot, Shumin Zhai<br/>
<a href="http://www.acm.org/sigchi/chi97/proceedings/paper/ja.htm">Beyond Fitts' Law: Models for Trajectory-Based HCI Tasks</a><br/>
In <a href="http://www.acm.org/sigchi/chi97/proceedings/">Proceedings CHI '97 Conference on Human Factors in Computing Systems</a><br/>
(Atlanta, GA, March 22-27, 1997). ACM, New York<br/>
<p><em>Abstract:</em></p>

<blockquote>Trajectory-based interactions, such as navigating
through nested-menus, drawing curves, and moving in 3D worlds, are
becoming common tasks in modern computer interfaces. Users'
performances in these tasks cannot be successfully modeled with
Fitts' law as it has been applied to pointing tasks. Therefore we
explore the possible existence of robust regularities in
trajectory-based tasks. We used "steering through tunnels" as our
experimental paradigm to represent such tasks, and found that a
simple "steering law" indeed exists. The paper presents the
motivation, analysis, a series of four experiments, and the
applications of the steering law.</blockquote>

<p><em>This is a more modern reference on Fitt's Law.</em></p>
</li>

<li>Ronald M. Baecker, William A. S. Buxton, editors<br/>
<strong>Readings in Human-Computer Interaction: A Multidisciplinary
Approach</strong><br/>
Morgan-Kaufmann Publishers, Los Altos, CA, 1987, ISBN
0-934613-24-9<br/>
<p>Chapter 6, <cite>Cognition and Human Information Processing</cite>
has Case Study C: Text Editors and Word Processors.</p>
</li>

<li>Gutknecht, J.<br/>
<strong>Concepts of the text editor Lara</strong><br/>
<cite>Communications of the ACM</cite>, vol 28, no 9, September 1985<br/>
<br/>
</li>

<li>Jim Joycebr/>
<strong><a href="http://www.cs.pdx.edu/~kirkenda/joy84.html">Interview with Bill Joy</a></strong><br/>
<cite>Unix Review</cite>, August 1984<br/>
<br/>
<p>True Tales of the Origin of <em>vi</em>.</p>
</li>

<li>Rick Kazman and Riston Tapp<br/>
<a
href="http://www.cgl.uwaterloo.ca/~rnkazman/prog-comp.ps">Determining
the Usefulness of Colour and Fonts in a Programming Task</a><br/>
<cite>Proceedings of the 3rd Workshop on Program Comprehension</cite>,
(Washington, DC), November 1994, pp. 154-161.<br/>
<p><em>Abstract:</em></p>

<blockquote>This paper reports on the results of an experiment that
was run in order to help determine if colour or font size was more
useful for displaying code in a programming task, and if so, which
was more useful. The null hypothesis of the experiment was that
neither colour nor font size were of any benefit to users in
programming tasks. The null hypothesis was refuted. It was
determined that the colour display mechanism both lessened the time
taken to perform a code optimization task, and was preferred by
subjects. The use of the font size display mechanism showed no
significant benefits.</blockquote>
</li>

<li>Michael Sellers<br/>
<a id="argument" name="argument"><strong>Designing for Demanding
Users</strong></a><br/>
<cite>interactions</cite>, vol 1, no 3, July 1994<br/>
ISSN 1072-5220, published quarterly by the Association for
Computing Machinery<br/>
<p><em>Excerpt:</em></p>

<blockquote>Despite the advent of WYSIWYG editors and graphical
symbolic debuggers, an easy way to pick a fight in a group of
software engineers is to express a preference for one of the two
old war horses <em>vi</em> and <em>emacs</em>. Both are
horrendously unusable, yet the loyalty remains and the battles rage
on.</blockquote>
</li>

<li>Cherie Hurwitz<br/>
<strong>A Theoretical and Experimental Comparison of vi and Emacs</strong><br/>
Used to live at http://gmtunx.ee.uct.ac.za/~cherie/ViEmacs/contents.html, now no longer available.<br/>

<br/>
<em>Abstract:</em> 

<blockquote>
<p>This study compares the two text editors vi and emacs using
first a theoretical approach based on some possible criteria of a
good user interface, and then using an experimental approach by
designing a World Wide Web page as a discussion forum.</p>

<p>It was discovered that emacs is superior in most respects to vi
for novice users who have not learned either editor yet. Although
emacs is easier to learn and more powerful than vi, vi can be used
by experienced users to produce the same results for editing text
as emacs.</p>

<p>For experienced users in one of the two editors, changing
editors will not provide any advantages for the user, and will only
consume time.</p>
</blockquote>
</li>

<li><a href="http://www.doc.ic.ac.uk/~wjk/">William Knottenbelt</a><br/>
<strong>A Comparative Study of Vi and Emacs from the Perspective of
Novice and Regular Users</strong><br/>
<br/>
<em>Abstract:</em> 

<blockquote>
<p>The editors vi and emacs were compared using a simple time-based
experimental method involving common text manipulations and a
post-test opinion survey by questionnaire. The subjects were twelve
students; six were novices and six were regular users. Significant
objective performance differences were confined to the novice
users; here emacs consistently outperformed vi with respect to time
taken to perform the tasks and the amount of help needed.
Subjectively, novices preferred emacs because of its more
predictable nature. Emacs was therefore the editor of choice for
the novice users tested. There appears to be no advantage for a
regular user of one editor to switch to the other.</p>
</blockquote>

<p><em>Mr Knottenbelt permitted me to hold a <a
href="knottenbelt.txt">copy</a> of his essay.</em></p>
</li>
</ul>

<hr />
<center>
<h1>Editor Implementation</h1>
</center>

<ul>
<li>Dennis Ritchie's notes on the seminal <a
href="http://cm.bell-labs.com/cm/cs/who/dmr/qed.html">QED</a>
editor, one of the first editors to use regular expressions.<br/>
<br/>
</li>

<li>Rob Pike<br/>
<a href="http://www.cs.bell-labs.com/sys/doc/sam/sam.pdf">The text editor sam</a><br/>
<cite>Software - Practice and Experience</cite>, vol 17, no 11
(1987), pp 813-845<br/>
<br/>
<em>Abstract:</em> 

<blockquote>
<p>Sam is an interactive multi-file text editor intended for bitmap
displays. A textual command language supplements the mouse-driven,
cut-and-paste interface to make complex or repetitive editing tasks
easy to specify. The language is characterized by the composition
of regular expressions to describe the structure of the text being
modified. The treatment of files as a database, with changes logged
as atomic transactions, guides the implementation and makes a
general `undo' mechanism straightforward.</p>

<p>Sam is implemented as two processes connected by a low-bandwidth
stream, one process handling the display and the other the editing
algorithms. Therefore it can run with the display process in a
bitmap terminal and the editor on a local host, with both processes
on a bitmap-equipped host, or with the display process in the
terminal and the editor in a remote host. By suppressing the
display process, it can even run without a bitmap terminal.</p>
</blockquote>

<p><em>This paper contains both a tutorial in the use of
<kbd>sam</kbd> and a description of its implementation.</em></p>
</li>

<li><a href="http://www.cs.unm.edu/~crowley/">Charles
Crowley</a><br/>
<a
href="http://www.cs.unm.edu/~crowley/papers/sds/sds.html"><strong>Data
Structures for Text Sequences</strong></a><br/>
<br/>
<em>Abstract:</em> 

<blockquote>The data structure used to maintain the sequence of
characters is an important part of a text editor. This paper
investigates and evaluates the range of possible data structures
for text sequences. The ADT interface to the text sequence
component of a text editor is examined. Six common sequence data
structures (array, gap, list, line pointers, fixed size buffers and
piece tables) are examined and then a general model of sequence
data structures that encompasses all six structures is presented.
The piece table method is explained in detail and its advantages
are presented. The design space of sequence data structures is
examined and several variations on the ones listed above are
presented. These sequence data structures are compared
experimentally and evaluated based on a number of criteria. The
experimental comparison is done by implementing each data structure
in an editing simulator and testing it using a synthetic load of
many thousands of edits. We also report on experiments on the
sensitivity of the results to variations in the parameters used to
generate the synthetic editing load.</blockquote>

</li>

<li>C. A. Finseth<br/>
<a href="http://www.finseth.com/~fin/craft/index.html"><strong>The
craft of text editing: Emacs for the modern
world</strong></a><br/>
Springer-Verlag TELOS, New York, NY, 1991, ISBN 0387976167 

<p><em>Apparently out of print, currently available on-line
only</em></p>
</li>

<li>Tim A. Wagner<br/>
<a
href="http://sunsite.berkeley.edu:80/Dienst/UI/2.0/Describe/ncstrl.ucb/CSD-97-946">
<strong>Practical Algorithms for Incremental Software Development
Environments</strong></a><br/>
University of California - Berkeley technical report
CSD-97-946<br/>
March 11, 1998<br/>
<br/>
<em>Abstract:</em> 

<blockquote>We describe an integrated collection of algorithms and
data structures to serve as the basis for a practical incremental
software development environment. A self-versioning representation
provides a uniform model that embraces both natural and programming
language documents in a single, consistent framework. Software
artifacts in this representation provide fine-grained change
reports to all tools in the environment. We then present algorithms
for the initial construction and subsequent maintenanceof
persistent, structured documents that support unrestricted user
editing. These algorithms possess several novel aspects: they are
more general than previous approaches, address issues of practical
importance, including scalability and information preservation, and
are optimal in both space and time. Since deterministic parsing is
too restrictive a model to describe some common programming
languages, we also investigate support for multiple structural
interpretations: incremental non-deterministic parsing is used to
construct a compact form that efficiently encodes syntactic
ambiguity. Later analyses may resolve ambiguous phrases through
syntactic or semantic disambiguation. This result provides the
first known method for handling C, C++, Fortran, and Cobol in an
incremental framework derived from formal specifications. Our
transformation and analysis algorithms are designed to avoid
spurious changes, which result in lost information and unnecessary
recomputation by later stages. We provide the first non-operational
definition of optimal node reuse in the context of incremental
parsing, and present optimal algorithms for retaining tokens and
nodes during incremental lexing and parsing. We also exploit the
tight integration between versioning and incremental analysis to
provide a novel *history-sensitive* approach to error handling. Our
error recovery mechanism reports problems in terms of the user's
own changes in a language-independent, non-correcting, automated,
and fully incremental manner. This work can be read at several
levels: as a refinement and extension of previous results to
address issues of scalability, end-to-end performance, generality,
and description reuse; as a `cookbook' for constructing the
framework of a practical incremental environment into which
semantic analysis, code generation, presentation, and other
services can be plugged; and as a set of separate (but
interoperable) solutions to open problems in the analysis and
representation of software artifacts. Our results are promising: in
addition to embracing a realistic language model, both asymptotic
and empirical measurements demonstrate that we have overcome
barriers in performance and scalability. Incremental methods can
now be applied to commercially important languages, and may finally
become the standard approach to constructing language-based tools
and services.</blockquote>
</li>

<li>Brooks, Kenneth P.<br/>
<strong>A Two-view Document Editor with User-definable Document
Structure</strong><br/>
Digital Systems Research Center Tech Report #33, November 1,
1988<br/>
<br/>
<em>Capsule Review:</em> 

<blockquote>
<p>In this report the author describes Lilac, a working interactive
system for typesetting complex documents. The novelty of the system
lies in that it allows both "changes in the small" and "changes in
the large" to be performed efficiently. More specifically, the user
works with two views of the document. One view is a WYSIWYG view,
emulating what will appear on the printed page. The other view
displays the structure of the document as a tree of nested
procedure calls - with the actual text appearing as arguments to
those procedures. An "interpretation" of that tree yields the
WYSIWYG view. The user is allowed to modify either the structure
view or the WYSIWYG view. The former is preferable for large
structure changes to the document; the latter for ordinary small
edits.</p>

<p>It is the job of Lilac to update one view when the other
changes, and to do so quickly. Accomplishing this has required
careful design and analysis on many fronts: the language in which
the document is specified, the data-structures for efficient
incremental reevaluation of the document tree, the algorithms for
performing selection in the document hierarchy, and finally the
caching scheme used to save still-useful parts of the WYSIWYG view.
All these pieces come together in Lilac, in a nicely integrated
design.</p>
</blockquote>
</li>

<li>
<p>This <a href="ftp://alf.uib.no:/pub/vi/docs/">FTP site</a>
carries several older articles on various text editor internals.
Look for files <code>editech.1.Z</code>, <code>editech.2.Z</code>,
<code>editech.3.Z</code>, <code>editech.4.Z</code> and
<code>editech.5.Z</code>. The files comprise a "personal view" of
text editor implementation. The author used the buffer gap method,
which Charles Crowley also examines in his <a
href="http://www.cs.unm.edu/~crowley/papers/sds/sds.html">paper.</a></p>
</li>
</ul>

<hr />
<h2>Related Pages</h2>

<ul>
<li>Roger Nelson's <a
href="http://www.bsyse.wsu.edu/~rnelson/editors/editors.htm">"Text
Editor Compendium"</a></li>

<li>Sven Guckes' <a
href="http://www.math.fu-berlin.de/~guckes/edit/">text editor
compendium</a></li>

<li>Nikolai Bezroukov's <a
href="http://www.softpanorama.org/Editors/index.shtml">Unix
Editors</a> page, ironically containing a lot more than just a list
of text editors available under Unix. This page contains both a
large number of links, and commentary from Bezroukov's unique
vantage point. He favors "folding" editors, and <a
href="http://www.softpanorama.org/Editors/eoe.shtml">editors
derived from Xedit</a>.</li>

<li>Sven Guckes' <a
href="http://www.math.fu-berlin.de/~guckes/pico/">Pico
evaluation</a></li>

<li>Sven Guckes' <a
href="http://www.math.fu-berlin.de/~guckes/textedit/">evaluation of
Sun's OpenLook</a> point-n-click editor</li>

<li>Sven Guckes' <a
href="http://www.math.fu-berlin.de/~guckes/vi/">Vi pages.</a> All
about vi and its clones.</li>

<li>Thomer M. Gil's <a
href="http://www.cs.vu.nl/%7Etmgil/vi.html">Vi Lovers Home
Page</a>.</li>

<li><a href="http://www.sfwriter.com/wordstar.htm">A WordStar
editor rant</a></li>

<li>Nelson Beebe's <a
href="http://www.math.utah.edu/ftp/pub/tex/bib/gnu.bib">EMACS
bibliography</a></li>

<li>GrammaTech, Inc.'s <a
href="http://www.grammatech.com/papers/RandD-bibliography.html">Language-Based
Environments: History and Bibliography</a></li>

<li>The <a
href="http://www.acm.org/cacm/AUG96/antimac.htm">Anti-Mac</a>
interface. This opinion piece from the August, 1996,
<cite>Communications of the ACM</cite> succinctly embodies a lot of
the "easy vs powerful" discussion.</li>
</ul>
<br/>
<br/>
<hr/>
<pre>
<em>$Id: perfect.editor.html,v 2.9 2000/02/29 15:52:44 bediger Exp bediger $</em>
</pre>
</body>
</html>
